<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fluid Mechanics Simulators</title>
  <style>
    /* ------ shared layout ------ */
    body {
      font-family: Arial, Helvetica, sans-serif;
      margin: 20px;
      background-color: #f0f8ff;
      color: #333;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #1a5276;
    }
    
    #appSelector {
      margin-bottom: 25px;
      text-align: center;
    }
    
    #appSelector button {
      margin: 0 10px 10px 0;
      padding: 8px 16px;
      font-size: 1rem;
      cursor: pointer;
      border: 1px solid #3498db;
      border-radius: 4px;
      background: #eaf6ff;
      transition: background .2s;
    }
    
    #appSelector button.active {
      background: #3498db;
      color: #fff;
    }
    
    .app {
      display: none;
      padding: 15px;
      border: 1px solid #bdc3c7;
      border-radius: 8px;
      background: #fff;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    
    .app.active {
      display: block;
    }
    
    h2 {
      text-align: center;
      margin-bottom: 15px;
      color: #2c3e50;
      padding-bottom: 8px;
      border-bottom: 1px solid #ecf0f1;
    }
    
    canvas {
      display: block;
      margin: 0 auto;
      background: #fff;
      border: 1px solid #bdc3c7;
    }
    
    /* ------ Fluid Projectile styles ------ */
    #fluidApp #controls {
      margin-bottom: 15px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #e1e4e8;
    }
    
    #fluidApp label {
      margin-right: 10px;
      font-size: 0.9rem;
    }
    
    #fluidApp .value {
      display: inline-block;
      width: 4ch;
      text-align: right;
      font-variant-numeric: tabular-nums;
      font-weight: bold;
      color: #2980b9;
    }
    
    #fluidApp input[type="range"] {
      width: 150px;
      margin-right: 15px;
    }
    
    #fluidApp .button-group {
      display: inline-block;
      margin-left: 20px;
    }
    
    #fluidApp button {
      margin-left: 10px;
      padding: 6px 12px;
      border: 1px solid #95a5a6;
      border-radius: 4px;
      background: #ecf0f1;
      cursor: pointer;
    }
    
    #fluidApp button:hover {
      background: #d6eaf8;
    }
    
    #fluidStats {
      background: #e8f4fc;
      padding: 10px;
      margin-bottom: 15px;
      border: 1px solid #bbdefb;
      border-radius: 4px;
      font-size: 0.95rem;
    }
    
    #fluidStats .formula {
      font-family: 'Courier New', monospace;
      margin-top: 5px;
      color: #2c3e50;
      background: #f0f7ff;
      padding: 5px;
      border-radius: 4px;
      display: inline-block;
    }
    
    /* ------ Continuity Equation styles ------ */
    #continuityApp #ceControls {
      margin-bottom: 15px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #e1e4e8;
    }
    
    #continuityApp label {
      margin-right: 14px;
      font-size: 0.9rem;
    }
    
    #continuityApp .value {
      display: inline-block;
      width: 5.5ch;
      text-align: right;
      font-variant-numeric: tabular-nums;
      font-weight: bold;
      color: #2980b9;
    }
    
    #continuityApp input[type="range"] {
      width: 150px;
      margin-right: 20px;
    }
    
    #continuityApp .button-group {
      display: inline-block;
      margin-left: 20px;
    }
    
    #ceInfoDisplay {
      background: #e8f4fc;
      padding: 15px;
      margin-bottom: 15px;
      border: 1px solid #bbdefb;
      border-radius: 4px;
      font-size: 0.95rem;
    }
    
    #ceInfoDisplay .formula {
      font-family: 'Courier New', monospace;
      margin: 8px 0;
      color: #2c3e50;
      background: #f0f7ff;
      padding: 8px;
      border-radius: 4px;
      display: block;
      text-align: center;
    }
    
    /* ------ Modal styles ------ */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }
    
    .modal-content {
      background: #fff;
      padding: 25px;
      border-radius: 8px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      position: relative;
    }
    
    .close-modal {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 24px;
      cursor: pointer;
      color: #7f8c8d;
    }
    
    .close-modal:hover {
      color: #e74c3c;
    }
    
    .modal h3 {
      color: #2980b9;
      margin-bottom: 15px;
      text-align: center;
    }
    
    .modal p {
      margin-bottom: 15px;
      line-height: 1.5;
    }
    
    .modal .formula {
      background: #f8f9fa;
      padding: 10px;
      border-left: 3px solid #3498db;
      font-family: 'Courier New', monospace;
      margin: 15px 0;
    }
  </style>
</head>
<body>
  <h1>Fluid Mechanics Simulators</h1>
  
  <div id="appSelector">
    <button data-app="fluid" class="active">üíß Fluid Projectile Simulator</button>
    <button data-app="continuity">‚û°Ô∏è Continuity Visualizer</button>
  </div>

  <!-- Fluid Projectile Modal -->
  <div id="fluidModal" class="modal">
    <div class="modal-content">
      <span class="close-modal">&times;</span>
      <h3>Fluid Projectile Simulator</h3>
      <p>This demonstration explores the behavior of fluid projected from a pressurized container through a nozzle, simulating projectile motion governed by fluid mechanics and kinematics. The simulator visualizes the fluid's parabolic trajectory as it exits the nozzle and follows a projectile path due to gravity.</p>
      <p>The goal is to optimize parameters so that the stream hits a designated target or splashes at a specific point, as seen in the diagram, where the water perfectly lands on the intended spot. This visualization demonstrates how fluid dynamics and physics principles can be applied in real-world systems like fountains, irrigation, or firefighting systems.</p>
      <div class="formula">v = ‚àö(2gh)</div>
      <p>Where <strong>v</strong> is the exit velocity, <strong>g</strong> is gravity (9.8 m/s¬≤), and <strong>h</strong> is the height difference between the water surface and the nozzle.</p>
    </div>
  </div>
  
  <!-- Continuity Modal -->
  <div id="continuityModal" class="modal">
    <div class="modal-content">
      <span class="close-modal">&times;</span>
      <h3>Continuity Equation Visualizer</h3>
      <p>This simulation demonstrates the continuity equation in fluid mechanics, which is expressed as:</p>
      <div class="formula">A‚ÇÅV‚ÇÅ = A‚ÇÇV‚ÇÇ</div>
      <p>This principle states that for an incompressible fluid flowing in a closed system, the product of the cross-sectional area (A) and the velocity (v) of the fluid remains constant along the stream. The image visualizes this concept using a narrowing pipe.</p>
      <p>As the pipe narrows, the cross-sectional area decreases, causing the fluid velocity to increase proportionally to maintain a constant flow rate. This principle is fundamental in fluid dynamics and explains phenomena like the Venturi effect.</p>
      <div class="formula">Q = A √ó v = œÄr¬≤ √ó v</div>
      <p>Where <strong>Q</strong> is the volumetric flow rate, <strong>A</strong> is the cross-sectional area, and <strong>v</strong> is the fluid velocity.</p>
    </div>
  </div>

  <!-- ================= FLUID PROJECTILE SIM ================= -->
  <section id="fluidApp" class="app active">
    <h2>Fluid Projectile Simulator</h2>
    
    <div id="fluidStats">
      <div><strong>Targets:</strong> <span id="score">Passed 0 / 3</span></div>
      <div><strong>Velocity:</strong> <span id="vDisplay">v ‚âà -- m/s</span></div>
      <div class="formula">v = ‚àö(2gh) = ‚àö(2 √ó 9.8 √ó <span id="h-value">--</span>)</div>
    </div>

    <div id="controls">
      <label>Angle Œ∏: <span id="angleVal" class="value">--</span>¬∞</label>
      <input type="range" id="angle" min="5" max="85" step="0.1" />
      
      <span id="radiusBlock">
        <label>Outlet Radius r: <span id="radiusVal" class="value">--</span> m</label>
        <input type="range" id="radius" min="0.024" max="0.05" step="0.002" />
      </span>
      
      <label id="waterBlock">Water Height h‚ÇÅ: <span id="waterHeightVal" class="value">--</span> m
        <input type="range" id="waterHeight" min="0" max="40" step="0.1" />
      </label>
      
      <span id="outletBlock">
        <label>Outlet Height h‚ÇÇ: <span id="outletHeightVal" class="value">--</span> m</label>
        <input type="range" id="outletHeight" min="0" max="20" step="0.1" />
      </span>
      
      <div class="button-group">
        <button id="resetBtn">üîÑ New Level</button>
        <button id="switchBtn">‚ñ∂ Next Scenario</button>
        <button id="infoBtn">‚ÑπÔ∏è Explanation</button>
      </div>
    </div>

    <canvas id="simCanvas" width="900" height="560"></canvas>
  </section>

  <!-- ================= CONTINUITY VISUALIZER ============== -->
  <section id="continuityApp" class="app">
    <h2>A‚ÇÅv‚ÇÅ = A‚ÇÇv‚ÇÇ ‚Äì Continuity Equation Playground</h2>
    
    <div id="ceInfoDisplay">
      <div class="formula">Continuity Equation: A‚ÇÅv‚ÇÅ = A‚ÇÇv‚ÇÇ</div>
      <div class="formula">Flow Rate: Q = A √ó v = œÄr¬≤ √ó v</div>
      <div class="formula">v‚ÇÅ = Q / (œÄ √ó r‚ÇÅ¬≤) = <span id="v1Value">--</span> m/s</div>
      <div class="formula">v‚ÇÇ = Q / (œÄ √ó r‚ÇÇ¬≤) = <span id="v2Value">--</span> m/s</div>
    </div>

    <div id="ceControls">
      <label>Flow Q (m¬≥/s): <span id="qVal" class="value">--</span></label>
      <input type="range" id="qRange" min="0.002" max="0.060" step="0.002"/>
      
      <label style="margin-left:24px;">Inlet r‚ÇÅ (m): <span id="r1Val" class="value">--</span></label>
      <input type="range" id="r1Range" min="0.05" max="0.30" step="0.01"/>
      
      <label style="margin-left:24px;">Outlet r‚ÇÇ (m): <span id="r2Val" class="value">--</span></label>
      <input type="range" id="r2Range" min="0.02" max="0.20" step="0.01"/>
      
      <div class="button-group">
        <button id="ceModeBtn">‚ö° Arrow Mode</button>
        <button id="ceResetBtn">üîÑ Reset</button>
        <button id="ceInfoBtn">‚ÑπÔ∏è Explanation</button>
      </div>
    </div>

    <canvas id="pipeCanvas" width="900" height="420"></canvas>
  </section>

  <!-- ================= SCRIPTS ================= -->
  <script>
    // App Switcher
    const selectorBtns = document.querySelectorAll('#appSelector button');
    selectorBtns.forEach(btn => btn.addEventListener('click', () => {
      selectorBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const showId = btn.dataset.app === 'fluid' ? 'fluidApp' : 'continuityApp';
      document.querySelectorAll('.app').forEach(sec => sec.classList.toggle('active', sec.id === showId));
    }));
    
    // Modal functionality
    const fluidModal = document.getElementById('fluidModal');
    const continuityModal = document.getElementById('continuityModal');
    const closeButtons = document.querySelectorAll('.close-modal');
    
    document.getElementById('infoBtn').addEventListener('click', () => {
      fluidModal.style.display = 'flex';
    });
    
    document.getElementById('ceInfoBtn').addEventListener('click', () => {
      continuityModal.style.display = 'flex';
    });
    
    closeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        fluidModal.style.display = 'none';
        continuityModal.style.display = 'none';
      });
    });
    
    window.addEventListener('click', (e) => {
      if (e.target === fluidModal) fluidModal.style.display = 'none';
      if (e.target === continuityModal) continuityModal.style.display = 'none';
    });
  </script>

  <!-- ================= FLUID SIM SCRIPT =================== -->
  <script>
    /********************* CONSTANTS *************************/
    const g = 9.8, scale = 10, pipeL = 30, groundOffset = 20, Q0 = 0.05;

    /****************** DOM REFS *****************************/
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const angleS = document.getElementById('angle');
    const radiusS = document.getElementById('radius');
    const hWaterS = document.getElementById('waterHeight');
    const hOutletS = document.getElementById('outletHeight');
    const resetBtn = document.getElementById('resetBtn');
    const switchBtn = document.getElementById('switchBtn');
    const angleLbl = document.getElementById('angleVal');
    const radiusLbl = document.getElementById('radiusVal');
    const hWaterLbl = document.getElementById('waterHeightVal');
    const hOutletLbl = document.getElementById('outletHeightVal');
    const scoreLbl = document.getElementById('score');
    const vDisp = document.getElementById('vDisplay');
    const waterBlock = document.getElementById('waterBlock');
    const radiusBlock = document.getElementById('radiusBlock');
    const outletBlock = document.getElementById('outletBlock');
    const hValue = document.getElementById('h-value');

    /****************** STATE *******************************/
    let scenario = 0; // 0: reservoir, 1: fixed-flow
    let targets = [], particles = [], splashes = [];
    let nozzle = { x: 10, y: 5 };
    let dragging = false, lastTime = null;

    /****************** UTILS *******************************/
    const rand = (min, max, step = 0.1) => +(min + Math.random() * ((max - min) / step | 0) * step).toFixed(3);

    function generateTargets(angleDeg, v0, origin) {
      const aRad = angleDeg * Math.PI / 180;
      const T = (v0 * Math.sin(aRad) + Math.sqrt(v0 * v0 * Math.sin(aRad) ** 2 + 2 * g * origin.y)) / g;
      const Fs = [0.25, 0.55, 0.85];
      targets = Fs.map(f => {
        const t = T * f;
        return { x: origin.x + v0 * Math.cos(aRad) * t, y: origin.y + v0 * Math.sin(aRad) * t - 0.5 * g * t * t, r: 1 };
      });
    }

    /****************** DEFAULT INPUTS **********************/
    function setDefaultSliders() {
      if (scenario === 0) {
        angleS.value = 45;            // mid angle
        hWaterS.value = 10;           // ensure > h2
        hOutletS.value = 2;
      } else {
        angleS.value = 45;
        radiusS.value = 0.035;
      }
      drawUI();
    }

    /****************** LEVEL BUILD *************************/
    function newLevel() {
      particles = []; splashes = [];
      if (scenario === 0) {
        const a = rand(15, 75, 0.1), h2 = rand(2, 10, 0.1), h1 = rand(h2 + 1, 35, 0.1), r = rand(0.01, 0.04, 0.005);
        // random parameters to create targets
        const v0 = Math.sqrt(2 * g * (h1 - h2));
        const origin = { x: (pipeL / scale) * Math.cos(a * Math.PI / 180), y: h2 + (pipeL / scale) * Math.sin(a * Math.PI / 180) };
        generateTargets(a, v0, origin);
      } else {
        const a = rand(20, 70, 0.1), r = rand(0.01, 0.04, 0.005);
        nozzle = { x: 10, y: 5 };
        const v0 = Q0 / (Math.PI * r * r);
        generateTargets(a, v0, nozzle);
      }
      // AFTER targets built, reset sliders so user must "fit" them
      setDefaultSliders();
      syncBlocks();
    }

    /****************** PARTICLE CLASSES *********************/
    class Drop {
      constructor(x, y, vx, vy) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.alpha = 1; this.land = false; }
      upd(dt) {
        if (!this.land) {
          this.vy -= g * dt; this.x += this.vx * dt; this.y += this.vy * dt;
          if (this.y <= 0) { this.y = 0; this.land = true; makeSplash(this.x, this.y, this.vx); }
        } else this.alpha -= dt * 2;
        return this.alpha > 0;
      }
      draw() { ctx.globalAlpha = Math.max(this.alpha, 0); const { cX, cY } = toCanvas(this.x, this.y); ctx.beginPath(); ctx.arc(cX, cY, 3, 0, 2 * Math.PI); ctx.fillStyle = '#1c80d0'; ctx.fill(); ctx.globalAlpha = 1; }
    }

    class Splash {
      constructor(x, y, vx, vy) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.a = 1; }
      upd(dt) { this.vy -= g * dt; this.x += this.vx * dt; this.y += this.vy * dt; this.a -= dt * 6; return this.a > 0; }
      draw() { ctx.globalAlpha = Math.max(this.a, 0); const { cX, cY } = toCanvas(this.x, this.y); ctx.fillStyle = '#55aaff'; ctx.fillRect(cX - 1, cY - 1, 3, 3); ctx.globalAlpha = 1; }
    }

    function makeSplash(x, y, hV) {
      for (let i = 0; i < 12; i++) {
        const ang = Math.random() * Math.PI; const sp = (0.8 + Math.random() * 0.8) * (Math.abs(hV) + 3);
        splashes.push(new Splash(x, y, sp * Math.cos(ang), sp * Math.sin(ang)));
      }
    }

    /****************** COORD CONVERSION *********************/
    const groundY = canvas.height - groundOffset;
    function toCanvas(x, y) {
      if (scenario === 0) { const px = 20 + 40; return { cX: px + x * scale, cY: groundY - y * scale }; }
      return { cX: x * scale, cY: groundY - y * scale };
    }

    /****************** EMIT DROPS **************************/
    function emit() {
      const aD = +angleS.value, aR = aD * Math.PI / 180, r = +radiusS.value; let v0, orig;
      if (scenario === 0) {
        const h1 = +hWaterS.value, h2 = +hOutletS.value; v0 = Math.sqrt(2 * g * Math.max(h1 - h2, 0)); if (!v0) return;
        orig = { x: (pipeL / scale) * Math.cos(aR), y: h2 + (pipeL / scale) * Math.sin(aR) };
      } else {
        v0 = Q0 / (Math.PI * r * r); orig = nozzle;
      }
      const vx = v0 * Math.cos(aR), vy = v0 * Math.sin(aR); const rate = Math.max(2, Math.round(r * 100));
      for (let i = 0; i < rate; i++) particles.push(new Drop(orig.x, orig.y, vx, vy));
    }

    /****************** RENDER ******************************/
    function drawStatic() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(canvas.width, groundY); ctx.strokeStyle = '#555'; ctx.stroke();
      if (scenario === 0) { ctx.fillStyle = '#add8e6'; ctx.fillRect(20, groundY - 400, 40, 400); }
    }

    function drawPipe() {
      if (scenario === 0) {
        const aR = +angleS.value * Math.PI / 180;
        const baseX = 20 + 40, baseY = groundY - (+hOutletS.value) * scale;
        const tipX = baseX + pipeL * Math.cos(aR), tipY = baseY - pipeL * Math.sin(aR);
        ctx.beginPath(); ctx.moveTo(baseX, baseY); ctx.lineTo(tipX, tipY); ctx.lineWidth = 5; ctx.strokeStyle = '#000'; ctx.stroke();
        ctx.beginPath(); ctx.ellipse(tipX, tipY, 6, 3, -aR, 0, 2 * Math.PI); ctx.fillStyle = '#333'; ctx.fill();
      } else {
        ctx.strokeStyle = '#444'; ctx.lineWidth = 5; ctx.beginPath();
        for (let i = 0; i <= 80; i++) {
          const t = i / 80; const x = nozzle.x * t; const y = nozzle.y * (t * t * (3 - 2 * t));
          const { cX, cY } = toCanvas(x, y); i ? ctx.lineTo(cX, cY) : ctx.moveTo(cX, cY);
        }
        ctx.stroke();
        const { cX, cY } = toCanvas(nozzle.x, nozzle.y);
        ctx.beginPath(); ctx.arc(cX, cY, 8, 0, 2 * Math.PI); ctx.fillStyle = '#222'; ctx.fill();
        ctx.beginPath(); ctx.moveTo(cX, cY);
        const aR = +angleS.value * Math.PI / 180;
        ctx.lineTo(cX + 20 * Math.cos(aR), cY - 20 * Math.sin(aR)); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
      }
    }

    function drawPrediction() {
      const aD = +angleS.value, aR = aD * Math.PI / 180; let v0, origin;
      if (scenario === 0) {
        const h1 = +hWaterS.value, h2 = +hOutletS.value; v0 = Math.sqrt(2 * g * Math.max(h1 - h2, 0)); if (!v0) return;
        origin = { x: (pipeL / scale) * Math.cos(aR), y: h2 + (pipeL / scale) * Math.sin(aR) };
      } else {
        v0 = Q0 / (Math.PI * radiusS.value * radiusS.value); origin = nozzle;
      }
      const T = (v0 * Math.sin(aR) + Math.sqrt(v0 * v0 * Math.sin(aR) ** 2 + 2 * g * origin.y)) / g;
      ctx.setLineDash([5, 5]); ctx.beginPath(); const tip = toCanvas(origin.x, origin.y); ctx.moveTo(tip.cX, tip.cY);
      for (let t = 0; t <= T; t += T / 250) {
        const x = origin.x + v0 * Math.cos(aR) * t; const y = origin.y + v0 * Math.sin(aR) * t - 0.5 * g * t * t;
        const { cX, cY } = toCanvas(x, y); if (cX > canvas.width || cY > groundY) break; ctx.lineTo(cX, cY);
      }
      ctx.strokeStyle = '#0077cc'; ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);
    }

    function drawFrame() {
      drawStatic(); if (scenario === 0) { ctx.fillStyle = '#87cefa'; ctx.fillRect(20, groundY - (+hWaterS.value) * scale, 40, (+hWaterS.value) * scale); }
      drawPipe(); drawPrediction(); particles.forEach(p => p.draw()); splashes.forEach(s => s.draw()); drawTargets(); drawUI();
    }

    function drawTargets() {
      const passed = targets.map(() => false);
      particles.forEach(p => { targets.forEach((tg, i) => { if (!passed[i] && !p.land && Math.hypot(p.x - tg.x, p.y - tg.y) < tg.r) passed[i] = true; }); });
      targets.forEach((tg, i) => {
        const { cX, cY } = toCanvas(tg.x, tg.y); ctx.beginPath(); ctx.arc(cX, cY, tg.r * scale, 0, 2 * Math.PI); ctx.lineWidth = 2; ctx.strokeStyle = passed[i] ? 'green' : 'red'; ctx.stroke();
      });
      scoreLbl.textContent = `Passed ${passed.filter(Boolean).length} / ${targets.length}`;
    }

    function syncBlocks() {
      if (scenario === 0) { waterBlock.style.display = 'inline'; radiusBlock.style.display = 'none'; outletBlock.style.display = 'inline'; }
      else { waterBlock.style.display = 'none'; radiusBlock.style.display = 'inline'; outletBlock.style.display = 'none'; }
    }

    function drawUI() {
      angleLbl.textContent = (+angleS.value).toFixed(1);
      radiusLbl.textContent = (+radiusS.value).toFixed(3);
      hWaterLbl.textContent = (scenario === 0 ? (+hWaterS.value).toFixed(1) : '--');
      hOutletLbl.textContent = (scenario === 0 ? (+hOutletS.value) : nozzle.y).toFixed(1);
      
      let v0 = 0;
      if (scenario === 0) {
        const h1 = +hWaterS.value, h2 = +hOutletS.value;
        v0 = Math.sqrt(2 * g * Math.max(h1 - h2, 0));
        hValue.textContent = (h1 - h2).toFixed(1);
      } else {
        v0 = Q0 / (Math.PI * radiusS.value * radiusS.value);
      }
      
      vDisp.textContent = `v ‚âà ${v0.toFixed(2)} m/s`;
      syncBlocks();
    }

    /****************** MAIN LOOP ***************************/
    function step(ts) {
      if (!lastTime) lastTime = ts; const dt = (ts - lastTime) / 1000; lastTime = ts;
      emit(); particles = particles.filter(p => p.upd(dt)); splashes = splashes.filter(s => s.upd(dt)); drawFrame(); requestAnimationFrame(step);
    }

    /****************** INTERACTION *************************/
    function pointerXY(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      return { x: (clientX - rect.left) / scale, y: (groundY - (clientY - rect.top)) / scale };
    }

    canvas.addEventListener('mousedown', e => {
      if (scenario !== 1) return;
      const { x, y } = pointerXY(e.clientX, e.clientY);
      if (Math.hypot(x - nozzle.x, y - nozzle.y) < 0.8) dragging = true;
    });

    window.addEventListener('mousemove', e => {
      if (!dragging) return; const p = pointerXY(e.clientX, e.clientY);
      nozzle.x = Math.min(Math.max(4, p.x), 20); nozzle.y = Math.min(Math.max(1, p.y), 15); hOutletS.value = nozzle.y;
    });
    window.addEventListener('mouseup', () => dragging = false);

    /* === Touch support === */
    canvas.addEventListener('touchstart', e => {
      if (scenario !== 1) return;
      const { x, y } = pointerXY(e.touches[0].clientX, e.touches[0].clientY);
      if (Math.hypot(x - nozzle.x, y - nozzle.y) < 0.8) { dragging = true; e.preventDefault(); }
    }, { passive: false });

    window.addEventListener('touchmove', e => {
      if (!dragging) return;
      const p = pointerXY(e.touches[0].clientX, e.touches[0].clientY);
      nozzle.x = Math.min(Math.max(4, p.x), 20); nozzle.y = Math.min(Math.max(1, p.y), 15); hOutletS.value = nozzle.y; e.preventDefault();
    }, { passive: false });

    window.addEventListener('touchend', () => dragging = false);

    resetBtn.addEventListener('click', newLevel);
    switchBtn.addEventListener('click', () => { scenario = (scenario + 1) % 2; newLevel(); });

    /****************** BOOT *******************************/
    newLevel(); requestAnimationFrame(step);
  </script>

  <!-- ================= CONTINUITY VISUALIZER SCRIPT ===== -->
  <script>
    /********* Constants *********/
    const ceScale = 100, L = 6, plateau = 0.25;
    const rowsPerM = 18;
    const wallGap = 0.92, arrowGap = 0.80;
    const DESIRED_SPACING = 0.25, DT_MIN = 0.05, DT_MAX = 0.4, MAX_PARTS = 2500;

    /********* DOM refs *********/
    const cvs = document.getElementById('pipeCanvas');
    const ctx2 = cvs.getContext('2d');
    const qR = document.getElementById('qRange');
    const r1R = document.getElementById('r1Range');
    const r2R = document.getElementById('r2Range');
    const modeBtn = document.getElementById('ceModeBtn');
    const resetBtn2 = document.getElementById('ceResetBtn');
    const qLbl = document.getElementById('qVal');
    const r1Lbl = document.getElementById('r1Val');
    const r2Lbl = document.getElementById('r2Val');
    const v1Value = document.getElementById('v1Value');
    const v2Value = document.getElementById('v2Value');

    /********* State *********/
    let mode = 'particle';
    let parts = [];
    let spawnClock = 0, spawnDt = 0.2, last = null;

    /********* Helpers *********/
    const toC = (x, y) => ({ cX: 60 + x * ceScale, cY: cvs.height / 2 - y * ceScale });
    function rProf(x, r1, r2) {
      const l = plateau * L, r = (1 - plateau) * L;
      if (x < l) return r1; if (x > r) return r2;
      const u = (x - l) / (r - l);
      return r1 + (r2 - r1) * (u * u * (3 - 2 * u));
    }

    /********* Drawing *********/
    function walls(r1, r2) {
      ctx2.strokeStyle = '#000'; ctx2.lineWidth = 2;
      ctx2.beginPath();
      for (let i = 0; i <= 300; i++) { const x = (i / 300) * L, r = rProf(x, r1, r2); const { cX, cY } = toC(x, r); i ? ctx2.lineTo(cX, cY) : ctx2.moveTo(cX, cY); }
      ctx2.stroke(); ctx2.beginPath();
      for (let i = 0; i <= 300; i++) { const x = (i / 300) * L, r = rProf(x, r1, r2); const { cX, cY } = toC(x, -r); i ? ctx2.lineTo(cX, cY) : ctx2.moveTo(cX, cY); }
      ctx2.stroke();
    }

    function arrows(Q, r1, r2) {
      ctx2.strokeStyle = '#1c80d0'; ctx2.lineWidth = 2;
      const cols = 12, eps = 0.02;
      for (let i = 0; i <= cols; i++) {
        const x = (i / cols) * L, r = rProf(x, r1, r2);
        const rL = rProf(Math.max(0, x - eps), r1, r2), rR = rProf(Math.min(L, x + eps), r1, r2);
        const drdx = (rR - rL) / (2 * eps), v = Q / (Math.PI * r * r);
        const baseLen = Math.min(1.2, 0.08 + v * 0.25), lines = Math.max(2, Math.round(r * rowsPerM / 1.5));
        for (let k = 0; k < lines; k++) {
          const frac = (k - (lines - 1) / 2) / ((lines - 1) / 2);
          const yWorld = frac * r * arrowGap;
          const slope = frac * drdx, norm = Math.sqrt(1 + slope * slope), dirX = 1 / norm, dirY = slope / norm;
          const { cX, cY } = toC(x, yWorld); const endX = cX + dirX * baseLen * ceScale, endY = cY - dirY * baseLen * ceScale;
          ctx2.beginPath(); ctx2.moveTo(cX, cY); ctx2.lineTo(endX, endY); ctx2.stroke();
          const headBackX = endX - dirX * 5, headBackY = endY + dirY * 5, perpX = -dirY, perpY = dirX;
          ctx2.beginPath(); ctx2.moveTo(endX, endY);
          ctx2.lineTo(headBackX + perpX * 3, headBackY + perpY * 3);
          ctx2.lineTo(headBackX - perpX * 3, headBackY - perpY * 3);
          ctx2.closePath(); ctx2.fillStyle = '#1c80d0'; ctx2.fill();
        }
      }
    }

    /********* Particle class *********/
    class P {
      constructor(frac) { this.x = 0; this.f = frac; this.remove = false; }
      update(dt, r1, r2, Q) {
        const r = rProf(this.x, r1, r2), v = Q / (Math.PI * r * r);
        this.x += v * dt; if (this.x > L) { this.remove = true; return; }
        this.y = this.f * r * wallGap;
      }
      draw() { const { cX, cY } = toC(this.x, this.y); ctx2.beginPath(); ctx2.arc(cX, cY, 2, 0, Math.PI * 2); ctx2.fillStyle = '#0080ff'; ctx2.fill(); }
    }
    function spawnRow(rIn) {
      const count = Math.max(2, Math.round(rIn * rowsPerM));
      for (let i = 0; i < count; i++) parts.push(new P(Math.random() * 2 - 1));
      if (parts.length > MAX_PARTS) parts.splice(0, parts.length - MAX_PARTS);
    }

    /********* Animation loop *********/
    function tick(ts) {
      if (!last) last = ts; const dt = (ts - last) / 1000; last = ts;
      const Q = +qR.value, r1 = +r1R.value, r2 = +r2R.value;
      const vIn = Q / (Math.PI * r1 * r1);
      const vOut = Q / (Math.PI * r2 * r2);
      
      // Update velocity displays
      v1Value.textContent = vIn.toFixed(2);
      v2Value.textContent = vOut.toFixed(2);
      
      spawnDt = Math.max(DT_MIN, Math.min(DT_MAX, DESIRED_SPACING / vIn));
      if (mode === 'particle') {
        spawnClock += dt; while (spawnClock >= spawnDt) { spawnClock -= spawnDt; spawnRow(r1); }
        parts.forEach(p => p.update(dt, r1, r2, Q)); parts = parts.filter(p => !p.remove);
      }
      ctx2.clearRect(0, 0, cvs.width, cvs.height); walls(r1, r2);
      if (mode === 'arrow') arrows(Q, r1, r2); else parts.forEach(p => p.draw());
      requestAnimationFrame(tick);
    }

    /********* UI Sync *********/
    function syncLabels() {
      qLbl.textContent = (+qR.value).toFixed(3);
      r1Lbl.textContent = (+r1R.value).toFixed(2);
      r2Lbl.textContent = (+r2R.value).toFixed(2);
    }
    qR.oninput = r1R.oninput = r2R.oninput = syncLabels;
    modeBtn.onclick = () => { mode = mode === 'arrow' ? 'particle' : 'arrow'; modeBtn.textContent = mode === 'arrow' ? '‚ö° Arrow Mode' : 'üíß Particle Mode'; syncLabels(); };
    resetBtn2.onclick = () => { qR.value = '0.010'; r1R.value = '0.25'; r2R.value = '0.06'; parts = []; spawnClock = 0; syncLabels(); };

    /********* Boot *********/
    (() => { qR.value = '0.010'; r1R.value = '0.25'; r2R.value = '0.06'; syncLabels(); spawnRow(+r1R.value); requestAnimationFrame(tick); })();
  </script>
</body>
</html>
